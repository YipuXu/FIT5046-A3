package com.example.fitlife.ui.calendar

import android.Manifest
import android.app.Application
import android.content.ContentUris
import android.content.ContentValues
import android.content.pm.PackageManager
import android.provider.CalendarContract
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.example.fitlife.data.model.FitnessEvent
import com.example.fitlife.data.repository.FitnessEventRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Calendar
import java.util.TimeZone

class CalendarViewModel(application: Application) : AndroidViewModel(application) {

    private val fitnessEventRepository: FitnessEventRepository = FitnessEventRepository(application)
    private val app: Application = application // Save the Application instance for easy access to the Context

    // Auxiliary function: Get the zero milliseconds of the date with a given millisecond
    private fun getStartOfDayMillis(millis: Long): Long {
        return Calendar.getInstance().apply {
            timeInMillis = millis
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }.timeInMillis
    }

    // --- State Management ---
    private val _selectedDateMillis = MutableStateFlow(getStartOfDayMillis(System.currentTimeMillis()))
    val selectedDateMillis: StateFlow<Long> = _selectedDateMillis.asStateFlow()

    val eventsForSelectedDate: StateFlow<List<FitnessEvent>> = _selectedDateMillis.flatMapLatest { dateMillis ->
        val dayStartMillis = getStartOfDayMillis(dateMillis)
        val nextDayStartMillis = Calendar.getInstance().apply {
            timeInMillis = dayStartMillis
            add(Calendar.DAY_OF_MONTH, 1)
        }.timeInMillis
        fitnessEventRepository.getEventsForDay(dayStartMillis, nextDayStartMillis)
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000L),
        initialValue = emptyList()
    )

    fun setSelectedDate(year: Int, month: Int, dayOfMonth: Int) {
        val calendar = Calendar.getInstance().apply {
            clear()
            set(year, month, dayOfMonth)
        }
        _selectedDateMillis.value = getStartOfDayMillis(calendar.timeInMillis)
    }

    fun addEvent(title: String, startTime: Long, endTime: Long, description: String?) {
        if (title.isBlank()) {
            println("CalendarViewModel:Error - Event title cannot be empty.")
            // TODO:
            return
        }
        if (startTime >= endTime) {
            println("CalendarViewModel:Error - Start time must be before end time.")
            // TODO:
            return
        }

        viewModelScope.launch {
            // Create an event object without an ID for inserting into Room
            val initialEventForRoom = FitnessEvent(
                title = title,
                startTime = startTime,
                endTime = endTime,
                description = description,
                systemCalendarEventId = null
            )
            // Insert Room and get the automatically generated local ID
            val localGeneratedId = fitnessEventRepository.insertEvent(initialEventForRoom)

            // Check permissions and try to sync to system calendar
            if (hasCalendarPermission(Manifest.permission.WRITE_CALENDAR) &&
                hasCalendarPermission(Manifest.permission.READ_CALENDAR)) {

                val systemEventId = addEventToSystemCalendarInternal(title, startTime, endTime, description)

                if (systemEventId != null) {
                    // If the synchronization is successful, update the event record in Room with the system calendar ID and local ID
                    val eventToUpdateInRoom = FitnessEvent(
                        id = localGeneratedId, // Use the ID generated by Room
                        title = title,
                        startTime = startTime,
                        endTime = endTime,
                        description = description,
                        systemCalendarEventId = systemEventId // Set the system calendar ID
                    )
                    fitnessEventRepository.updateEvent(eventToUpdateInRoom)
                    println("CalendarViewModel: Events have been synchronized to the system calendar, system ID: $systemEventId")
                } else {
                    println("CalendarViewModel: Failed to synchronize events to the system calendar or no writable calendar was found. Events are only saved locally.")
                    // TODO
                }
            } else {
                println("CalendarViewModel: Calendar permissions not granted. Events are saved locally only.")
                // TODO
            }
        }
    }

    fun deleteEvent(event: FitnessEvent) {
        viewModelScope.launch {
            // Delete from Room database
            fitnessEventRepository.deleteEvent(event)
            println("CalendarViewModel: The event has been deleted from the local database: ${event.title}")

            // If the event has been synced to the system calendar, delete it from the system calendar
            event.systemCalendarEventId?.let { sysId ->
                if (hasCalendarPermission(Manifest.permission.WRITE_CALENDAR)) {
                    val success = deleteEventFromSystemCalendarInternal(sysId)
                    if (success) {
                        println("CalendarViewModel: Event deleted from system calendar, System ID: $sysId")
                    } else {
                        println("CalendarViewModel: Failed to delete event from system calendar, System ID: $sysId")
                        // TODO
                    }
                } else {
                    println("CalendarViewModel: Unable to delete event from system calendar without calendar write permission. Local event deleted.")
                    // TODO
                }
            }
        }
    }

    // --- Private Helper Methods ---

    private fun hasCalendarPermission(permission: String): Boolean {
        return ContextCompat.checkSelfPermission(
            app.applicationContext,
            permission
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Query a writable calendar ID on the user's phone.
     * Give priority to the primary calendar. If it cannot be found, select the first writable calendar.
     * Execute in the IO thread.
     */
    private suspend fun getWritableCalendarId(): Long? = withContext(Dispatchers.IO) {
        if (!hasCalendarPermission(Manifest.permission.READ_CALENDAR)) {
            println("CalendarViewModel: Without permission to read the calendar, unable to get the calendar ID.")
            return@withContext null
        }

        val projection = arrayOf(
            CalendarContract.Calendars._ID,
            CalendarContract.Calendars.CALENDAR_DISPLAY_NAME,
            CalendarContract.Calendars.IS_PRIMARY,
            CalendarContract.Calendars.CALENDAR_ACCESS_LEVEL
        )

        // Find the primary calendar and the calendar where the app has at least Contributor permissions
        var selection = "(${CalendarContract.Calendars.IS_PRIMARY} = ?) AND (${CalendarContract.Calendars.CALENDAR_ACCESS_LEVEL} >= ?)"
        var selectionArgs = arrayOf("1", CalendarContract.Calendars.CAL_ACCESS_CONTRIBUTOR.toString())

        val contentResolver = app.contentResolver
        var calendarId: Long? = null

        try {
            contentResolver.query(
                CalendarContract.Calendars.CONTENT_URI,
                projection,
                selection,
                selectionArgs,
                null
            )?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val idIndex = cursor.getColumnIndexOrThrow(CalendarContract.Calendars._ID)
                    val nameIndex = cursor.getColumnIndexOrThrow(CalendarContract.Calendars.CALENDAR_DISPLAY_NAME)
                    calendarId = cursor.getLong(idIndex)
                    println("CalendarViewModel: Find the primary writable calendar: ID=${cursor.getLong(idIndex)}, Name=${cursor.getString(nameIndex)}")
                }
            }

            // If the primary calendar is not found, then try to find any writable calendar
            if (calendarId == null) {
                println("CalendarViewModel: No primary writable calendar found, trying to find another writable calendar...")
                selection = "(${CalendarContract.Calendars.CALENDAR_ACCESS_LEVEL} >= ?)"
                selectionArgs = arrayOf(CalendarContract.Calendars.CAL_ACCESS_CONTRIBUTOR.toString())
                contentResolver.query(
                    CalendarContract.Calendars.CONTENT_URI,
                    projection,
                    selection,
                    selectionArgs,
                    CalendarContract.Calendars._ID + " ASC LIMIT 1" // Get the first one that meets the conditions
                )?.use { cursor ->
                    if (cursor.moveToFirst()) {
                        val idIndex = cursor.getColumnIndexOrThrow(CalendarContract.Calendars._ID)
                        val nameIndex = cursor.getColumnIndexOrThrow(CalendarContract.Calendars.CALENDAR_DISPLAY_NAME)
                        calendarId = cursor.getLong(idIndex)
                        println("CalendarViewModel: Find other writable calendars: ID=${cursor.getLong(idIndex)}, Name=${cursor.getString(nameIndex)}")
                    }
                }
            }
        } catch (e: Exception) {
            println("CalendarViewModel: Error querying calendar ID: ${e.message}")
            e.printStackTrace()
            return@withContext null
        }

        if(calendarId == null) {
            println("CalendarViewModel: Finally no writable calendar ID was found。")
        }
        return@withContext calendarId
    }

    /**
     * Internal method that actually performs the operation of adding the event to the system calendar.
     * Executed on the IO thread.
     */
    private suspend fun addEventToSystemCalendarInternal(
        title: String,
        startTime: Long,
        endTime: Long,
        description: String?
    ): Long? = withContext(Dispatchers.IO) {
        val calendarId = getWritableCalendarId() // This method has checked the READ_CALENDAR permission inside
        if (calendarId == null) {
            println("CalendarViewModel: addEventToSystemCalendarInternal - No writable calendar ID found。")
            return@withContext null
        }
        if (!hasCalendarPermission(Manifest.permission.WRITE_CALENDAR)) {
            println("CalendarViewModel: addEventToSystemCalendarInternal - No permission to write to calendar。")
            return@withContext null
        }


        val contentResolver = app.contentResolver
        val values = ContentValues().apply {
            put(CalendarContract.Events.DTSTART, startTime)
            put(CalendarContract.Events.DTEND, endTime)
            put(CalendarContract.Events.TITLE, title)
            put(CalendarContract.Events.DESCRIPTION, description ?: "")
            put(CalendarContract.Events.CALENDAR_ID, calendarId)
            put(CalendarContract.Events.EVENT_TIMEZONE, TimeZone.getDefault().id)
        }

        return@withContext try {
            val uri = contentResolver.insert(CalendarContract.Events.CONTENT_URI, values)
            val systemEventId = uri?.lastPathSegment?.toLongOrNull()
            println("CalendarViewModel: Event successfully inserted into the system calendar，URI: $uri, SystemEventID: $systemEventId")
            systemEventId
        } catch (e: SecurityException) {
            println("CalendarViewModel: Permission error writing to system calendar: ${e.message}")
            e.printStackTrace()
            null
        } catch (e: Exception) {
            println("CalendarViewModel: An unknown error occurred while writing to the system calendar: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Internal method that actually performs the operation of deleting events from the system calendar.
     * Executed on the IO thread.
     * @param systemEventId The ID of the system calendar event to be deleted.
     * @return Returns true if the deletion is successful, otherwise returns false.
     */
    private suspend fun deleteEventFromSystemCalendarInternal(systemEventId: Long): Boolean = withContext(Dispatchers.IO) {
        if (!hasCalendarPermission(Manifest.permission.WRITE_CALENDAR)) {
            println("CalendarViewModel: No permission to write to the calendar")
            return@withContext false
        }

        val contentResolver = app.contentResolver
        val deleteUri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, systemEventId)

        return@withContext try {
            val rowsDeleted = contentResolver.delete(deleteUri, null, null)
            if (rowsDeleted > 0) {
                println("CalendarViewModel: Successfully deleted the event from the system calendar，SystemID: $systemEventId, Number of rows affected: $rowsDeleted")
                true
            } else {
                println("CalendarViewModel: When you delete an event from the system calendar, no rows are affected.SystemID: $systemEventId")
                false
            }
        } catch (e: SecurityException) {
            println("CalendarViewModel: Permission error when deleting event from system calendar: ${e.message}")
            e.printStackTrace()
            false
        } catch (e: Exception) {
            println("CalendarViewModel: An unknown error occurred while deleting the event from the system calendar: ${e.message}")
            e.printStackTrace()
            false
        }
    }
}